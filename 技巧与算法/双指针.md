1. 分类
   1. 左右指针：指针相向而行或相背而行
   2. 快慢指针：指针同向而行，一快一慢
2. 试用场景
   1. 快慢指针
      1. 单链表一般都是，因为单链表是单向的
3. 题眼：数组**有序**
4. 其他：数组中一般将索引当做指针来使用

# 基于数组的双指针

## 删除有序数组中的重复项

1. 标签：有序数组，原地删除，重复项，交换位置
2. 思路：定义快慢指针 slow 和 fast，让 fast 走在前面，当 slow 和 fast 所指的东西不同时，用 fast 来取代给 slow，如图
   ![image-20240920220941148](.\img\image-20240920220941148.png)
3. 模板：模板只做参考
   
   ```C++
   class Solution {
   public:
       int removeElement(vector<int>& nums, int val) {
           int fast = 0, slow = 0;
           while (fast < nums.size()) {
               if (nums[fast] != val) {
                   nums[slow] = nums[fast];
                   slow++;
               }
               fast++;
           }
           return slow;
       }
   };
   ```
4. 例题
   
   1. [26\_简单_删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)【通过】
   2. [27\_简单_移除元素](https://leetcode.cn/problems/remove-element/description/)【通过】

## 滑动窗口

见滑动窗口

## 左右指针

### 二分查找

见二分查找

### n 数之和

1. 标签：**有序**，n 数之和
2. 思路：左右指针 left 和 right 一开始分别指向数组两端，若 num[left] + num[right] > 目标值，说明 right 值大了，则 right--，反之说明 left 值小了，left++（重点是因为数组有序，所以可以这么做）
3. 例题
   1. [167\_中等_两数之和 || - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/)


### 反转数组

1. 标签：左右指针
2. 思路：反转数组的原理非常简单，就是将 left 和 right 指针置于数组两端，交换两端的值就好

```cpp
void reverseString(vector<char>& s) {
    // 一左一右两个指针相向而行
    int left = 0, right = s.size() - 1;
    while (left < right) {
        // 交换 s[left] 和 s[right]
        char temp = s[left];
        s[left] = s[right];
        s[right] = temp;
        left++;
        right--;
    }
}
```

### 回文串判断

1. 标签：左右指针
   1. 从两边向内
   2. 从中心向两边
2. 思路：对于普通的回文串可以使用从两边向内的方式来判断回文串。而对于最长回文串考虑使用从中心向两边的方式来判断
3. 例题
   1. 普通回文串判断：比如判断“aba”是不是回文串
      ```cpp
      bool isPalindrome(string s) {
          // 一左一右两个指针相向而行
          int left = 0, right = s.length() - 1;
          while (left < right) {
              if (s[left] != s[right]) {
                  return false;
              }
              left++;
              right--;
          }
          return true;
      }
      ```
   2. [5\_中等_最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/description/)
      
      ```cpp
      // 在 s 中寻找以 s[l] 和 s[r] 为中心的最长回文串
      // 输入相同的 l 和 r 相等于寻找奇数（只有一个中心点）的回文串
      // 输入相邻的 l 和 r 相等于寻找偶数（有两个中心点）的回文串
      std::string palindrome(std::string s, int l, int r) {
          // 防止索引越界
          while (l >= 0 && r < s.length()
                  && s[l] == s[r]) {
              // 双指针，向两边展开
              l--; r++;
          }
          // 返回以 s[l] 和 s[r] 为中心的最长回文串
          return s.substr(l + 1, r-l-1);
      }
      
      // 内部调用 palindrome
      string longestPalindrome(string s) {
          string res = "";
          for (int i = 0; i < s.length(); i++) {
              // 以 s[i] 为中心的最长回文子串
              string s1 = palindrome(s, i, i);
              // 以 s[i] 和 s[i+1] 为中心的最长回文子串
              string s2 = palindrome(s, i, i + 1);
              // 寻找最长
              res = res.length() > s1.length() ? res : s1;
              res = res.length() > s2.length() ? res : s2;
          }
          return res;
      }
      ```

# 基于单链表的双指针

1. 常见题目
   1. 合并 k 个有序链表
   2. 链表分解
   3. 寻找单链表的倒数第 k 个节点
   4. 寻找单链表的中点
   5. 判断单链表是否包含环以及环的起点
   6. 判断两个单链表是否相交以及交点

## 合并两个有序链表

1. 标签：普通双指针，虚拟头结点
2. 思路：构造一个头结点（方便很多），然后两个指针分别指向两个单链表，然后进行比较
3. 例题：[21\_简单_合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/description/)

```cpp
class Solution {
   public:
       ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
           // 虚拟头结点
           ListNode dummy(-1), *p = &dummy;
           ListNode *p1 = l1, *p2 = l2;

           while (p1 != nullptr && p2 != nullptr) {
               // 比较 p1 和 p2 两个指针
               // 将值较小的的节点接到 p 指针
               if (p1->val > p2->val) {
                   p->next = p2;
                   p2 = p2->next;
               } else {
                   p->next = p1;
                   p1 = p1->next;
               }
               // p 指针不断前进
               p = p->next;
           }

           if (p1 != nullptr) {
               p->next = p1;
           }

           if (p2 != nullptr) {
               p->next = p2;
           }

           return dummy.next;
       }
   };
```